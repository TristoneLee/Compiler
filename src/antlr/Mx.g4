grammar Mx;primaryExpression    :   Identifier    |   Constant    |   '(' expression ')'    ;postfixExpression    :    primaryExpression	('[' expression ']'    | '(' argumentExpressionList? ')'    | ('.' | '->') Identifier    | ('++' | '--')    )*    ;argumentExpressionList    :   assignmentExpression (',' assignmentExpression)*    ;unaryExpression    :    ('++' |  '--' )*    (postfixExpression    |   unaryOperator castExpression    )    ;unaryOperator    :   '&' | '*' | '+' | '-' | '~' | '!'    ;castExpression    :   unaryExpression    |   DigitSequence // for    ;multiplicativeExpression    :   castExpression (('*'|'/'|'%') castExpression)*    ;additiveExpression    :   multiplicativeExpression (('+'|'-') multiplicativeExpression)*    ;shiftExpression    :   additiveExpression (('<<'|'>>') additiveExpression)*    ;relationalExpression    :   shiftExpression (('<'|'>'|'<='|'>=') shiftExpression)*    ;equalityExpression    :   relationalExpression (('=='| '!=') relationalExpression)*    ;andExpression    :   equalityExpression ( '&' equalityExpression)*    ;exclusiveOrExpression    :   andExpression ('^' andExpression)*    ;inclusiveOrExpression    :   exclusiveOrExpression ('|' exclusiveOrExpression)*    ;logicalAndExpression    :   inclusiveOrExpression ('&&' inclusiveOrExpression)*    ;logicalOrExpression    :   logicalAndExpression ( '||' logicalAndExpression)*    ;conditionalExpression    :   logicalOrExpression ('?' expression ':' conditionalExpression)?    ;assignmentExpression    :   conditionalExpression    |   unaryExpression assignmentOperator assignmentExpression    |   DigitSequence // for    ;assignmentOperator    :   '='    ;expression    :   assignmentExpression (',' assignmentExpression)*    ;constantExpression    :   conditionalExpression    ;typeSpecifier	:   ('void'    |   'string'    |   'bool'    |   'int')    |   typedefName    ;typedefName	:   Identifier	;declaration	:   typeSpecifier initDeclaratorList ';'	;//todo why use Identifier rather than declarationinitDeclaratorList	:   initDeclarator (',' initDeclarator)*	;initDeclarator	:   Identifier ('=' initializer)?	;initializer	:Break : 'break';Continue : 'continue';Else : 'else';For : 'for';If : 'if';Int : 'int';Return : 'return';Void : 'void';While : 'while';True : 'true';False : 'false';New : 'new';LeftParen : '(';RightParen : ')';LeftBracket : '[';RightBracket : ']';LeftBrace : '{';RightBrace : '}';Less : '<';LessEqual : '<=';Greater : '>';GreaterEqual : '>=';LeftShift : '<<';RightShift : '>>';Plus : '+';PlusPlus : '++';Minus : '-';MinusMinus : '--';Star : '*';Div : '/';Mod : '%';And : '&';Or : '|';AndAnd : '&&';OrOr : '||';Caret : '^';Not : '!';Tilde : '~';Question : '?';Colon : ':';Semi : ';';Comma : ',';Assign : '=';Equal : '==';NotEqual : '!=';Arrow : '->';Dot : '.';Identifier    :   IdentifierNondigit        (   IdentifierNondigit        |   Digit        )*    ;fragmentIdentifierNondigit    :   Nondigit    ;fragmentNondigit    :   [a-zA-Z_]    ;fragmentDigit    :   [0-9]    ;fragmentNonzeroDigit    :   [1-9]    ;Constant    :   NonzeroDigit Digit*    ;DigitSequence    :   Digit+    ;fragmentEscapeSequence	:'\\' ["n\\]	;Whitespace    :   [ \t]+        -> skip    ;Newline    :   (   '\r' '\n'?        |   '\n'        )        -> skip    ;LineComment    :   '//' ~[\r\n]*        -> skip    ;